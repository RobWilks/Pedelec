/*Begining of Auto generated code by Atmel studio */
#include <Arduino.h>

/*End of auto generated code by Atmel studio */

// Speed Derestrictor
// Rob Wilkinson
// 15 Nov 2019
//
//                                 ATMEL ATTINY 85
//
//                                     +-\/-+
// (PCINT5/RESET/ADC0/dW)        PB5  1|    |8  Vcc
// (PCINT3/XTAL1/OC1B/ADC3)      PB3  2|    |7  PB2 (SCK/USCK/SCL/ADC1/T0/INT0/PCINT2)
// (PCINT4/XTAL2/CLKO/OC1B/ADC2) PB4  3|    |6  PB1 (MISO/DO/AIN1/OC0B/OC1A/PCINT1)
//                               GND  4|    |5  PB0 (MOSI/DI/SDA/AIN0/OC0A/OC1A/AREF/PCINT0)
//                                     +----+
// reedSwitchPin PB2;     // port of the reed switch (physical pin above)
// electromagnetPin1 PB3;     // two EM ports
// electromagnetPin2 PB4;     //
// ledEMPin PB0;        // shows EM status
// ledSleepPin PB1;       // LED to show sleeping


#include <Sleepy.h>
#include <avr/sleep.h>    // Sleep Modes
#include <avr/power.h>



const uint32_t timeDebounce = 1; //debouncing time in milliseconds
const uint32_t timeOutputPulse = 20; // duration of electromagnet pulse in milliseconds.  Works with 30, but >>higher than values calculated from transit of permanent magnet
const uint32_t timeSleep = 30000; // elapsed time before shutdown in milliseconds
const uint32_t timeSlowest = 4000; // for values larger than this threshold an input pulse immediately triggers an output pulse - 4000msec is approx 2kmh
const uint32_t timeSlow = 800; // timeLow is a threshold time of revolution. For values smaller than this threshold the electromagnet pulse frequency is reduced - 800msec is approx 10kmh
const uint32_t timeFast = 330; // second threshold time of revolution. For values smaller than this threshold the electromagnet pulse frequency is constant - 330msec is approx 24kmh
const uint32_t timeMaxTransit = 90; // maximum duration of reed switch pulse in msec
const uint32_t distSensorAxle = 300;  // normal distance from reed switch magnet to axle in mm. To do calculate time thresholds from sensor position
const uint32_t kappa = ((timeSlow - timeFast) << 10) / (timeSlow + (timeFast >> 2) - (timeFast >> 1)); // constant relating input and output frequencies; we calculate 1024 


// variables will change:
uint32_t timeNow;
uint32_t timeStart;  // time when reed switch goes LOW
uint32_t timeEnd;  // time when reed switch goes HIGH
uint32_t timeRev;  // duration reed switch closed
uint32_t timePulseOn; // time for next pulse to electromagnet
uint32_t timePulseOff; // time to turn off electromagnet
uint32_t timeDelta; // time between electromagnet pulses
uint32_t timeLastPulse; // time of start of last EM pulse
bool oldState; // was reed switch open?
bool newState; // is reed switch open?
bool electromagnetState; // is electromagnet on?

static volatile byte watchdogCounter;

/////////////////////////////////////////////////////////////////////////
// boilerplate for low-power waiting
ISR(WDT_vect)
{
	Sleepy::watchdogEvent();
}

/////////////////////////////////////////////////////////////////////////
ISR (INT0_vect)          //External interrupt_zero ISR
{
}
/////////////////////////////////////////////////////////////////////////
void sleep()
// powerdown and wake on external interrupt
{
	GIMSK |= _BV(INT0);                     // Enable INT0 Interrupts
	MCUCR &= 0xfc;                          // ISC01 ISC00 0 0 Level LOW on INT0 generates an interrupt request.
    byte adcsraSave = ADCSRA;
    ADCSRA &= ~ bit(ADEN);					// disable the ADC
	set_sleep_mode(SLEEP_MODE_PWR_DOWN);    //
	sleep_enable();                         // Sets the Sleep Enable bit in the MCUCR Register (SE BIT)
	sei();                                  // Enable interrupts
	sleep_cpu();                            // sleep
	cli();                                  // Disable interrupts
	GIMSK &= ~_BV(INT0);                    // Disable INT0 Interrupts
	sleep_disable();                        // Clear SE bit
    ADCSRA = adcsraSave;					// restore the ADC
	sei();                                  // Enable interrupts
} // sleep
/////////////////////////////////////////////////////////////////////////

uint32_t calcTimeDelta(uint32_t dt)
{
	if (dt > timeSlow) return dt;
	uint32_t deltaT = ((timeSlow << 10) - (timeSlow - dt) * kappa) >> 10;
	if (deltaT < timeFast) return timeFast;
	return deltaT;
}
/////////////////////////////////////////////////////////////////////////
void flash(uint8_t nTimes)
{
	for (uint8_t i = 0; i <= nTimes; i++)
	{
		PORTB |= (1 << PB1);
		delay(100);
		PORTB &= ~(1 << PB1);
		delay(400);
	}
}
/////////////////////////////////////////////////////////////////////////
bool checkTest(uint8_t n)
// returns true if reed switch closed for 20 sec
{
	bool pinState = false;
	uint8_t i = 0;
	while ((i <= n) && !pinState) // enter test state after n sec
	{
		pinState = bool(PINB >> PINB2);
		delay(1000);
		i++;
	}
	return (!pinState);
}
/////////////////////////////////////////////////////////////////////////
void test()
{
	bool pinState = false;
	int8_t nTimes = 0;
	while (!pinState)
	{
		pinState = bool(PINB >> PINB2);
		if (nTimes < 60) // stays in test but stops pulses after 4 minutes to avoid inadvertent battery drain
		// and sleeps using watchdog timer
		{
		PORTB |= ((1 << PB0) | (1 << PB3) | (1 << PB4));
		++nTimes;
		delay(timeOutputPulse);
		PORTB &= ~((1 << PB0) | (1 << PB3) | (1 << PB4));
		delay(1000);
		++nTimes;
		}
		else
		{
			Sleepy::loseSomeTime(8000);
		}
	}
}
/////////////////////////////////////////////////////////////////////////

void initState()
{
	timeEnd = millis();
	timePulseOn = 0xffffffff;
	timeLastPulse = timeEnd;
	oldState = HIGH;
	electromagnetState = LOW;
	timeDelta = 0; // when 0 EM cannot be turned on
	flash(3);

}

/////////////////////////////////////////////////////////////////////////

void setup()
{
	PORTB = (1 << PB2); // PB2 has a pull-up
	DDRB = ((1 << DDB0) | (1 << DDB1) | (1 << DDB3) | (1 << DDB4)); // 4 ports are outputs and 2 inputs
	ADCSRA &= ~ bit(ADEN);					// disable the ADC to save power
	initState();
}



/////////////////////////////////////////////////////////////////////////

void loop()
{
	newState = bool(PINB >> PINB2);
	
	if(newState != oldState)
	{
		delay(timeDebounce);  // this delays the main loop and reduces accuracy of other timing
		if (newState == bool(PINB >> PINB2))
		{
			oldState = newState;
			if (newState == LOW)
			{
				timeStart = millis();
			}
			else
			{
				timeNow = millis();
				if ((timeNow - timeStart) < timeMaxTransit) // check got expected pulse	duration
				{
					timeRev = timeNow - timeEnd;
					timeEnd = timeNow;
					timeDelta = calcTimeDelta(timeRev); // calculate the time between successive EM pulses
					if (timeDelta < timeSlowest) // unsure whether the two conditions are needed. Wanted to ensure motor control circuit receives pulses immediately when the bike begins to move
					{
						timePulseOn = timeLastPulse + timeDelta; // set time for next EM pulse
					}
					else
					{
						timePulseOn = timeNow;	// fire EM immediately at low speeds
					}
				}
			}
		}
	}
	

	
	if (electromagnetState)
	{
		if (millis() >= timePulseOff)  // turn off EM
		{
			PORTB &= ~((1 << PB0) | (1 << PB3) | (1 << PB4));
			electromagnetState = LOW;
		}
	}
	else
	{
		timeNow = millis();
		if ((timeNow >= timePulseOn) && (timeDelta != 0)) // turn on EM
		{
			PORTB |= ((1 << PB0) | (1 << PB3) | (1 << PB4));
			electromagnetState = HIGH;
			timePulseOff = timeNow + timeOutputPulse;  // set time to turn off EM
			timeLastPulse = timeNow;
			timeDelta = 0; // require recalculation of timeDelta before next EM pulse
		}
		else // can sleep only if EM is off
		{
			if ((timeNow - timeEnd) > timeSleep)
			{
					flash(5);
					sleep();
					if (checkTest(20)) 
					{
						test();
					}
					initState();  // all state variables initialised after sleep
			}
		}
	}
}
